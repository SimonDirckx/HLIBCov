//// Project     : HLib// File        : loglikelihood.cc// Description : example for 1d BEM problem// Author      : Alexander Litvinenko, Ronald Kriemann// Copyright   : Max Planck Institute MIS 2004-2018. All Rights Reserved.//#include <iostream>#include <fstream>#include <sstream>#include <vector>#include <boost/format.hpp>#include <boost/program_options.hpp>#include <boost/math/tools/minima.hpp>#include <gsl/gsl_sf_bessel.h>#include <gsl/gsl_sf_gamma.h>#include <hlib.hh>#include "../src/include/term.hh"using namespace std;using boost::format;using namespace boost::program_options;using namespace HLIB;using namespace HLIB::Term;using real_t = HLIB::real;template < typename T >stringmem_per_dof ( T && A ){    const size_t  mem  = A->byte_size();    const size_t  pdof = size_t( double(mem) / double(A->rows()) );    return Mem::to_string( pdof ) + "/dof";    // return Mem::to_string( mem );}const double  SQRT_3 = std::sqrt( 3 );const double  SQRT_5 = std::sqrt( 5 );//// covariance coefficient function//class TMaternCovarianceCoeffFn : public TPermCoeffFn< real_t >{private:    enum matern_type_t { one_half, three_half, five_half, general };        const double               _length;    const double               _nu;    const double               _sigmasq;    const double               _nugget;    const double               _scale_fac;    const vector< T2Point > &  _vertices;    const matern_type_t        _matern_type;public:    // constructor    TMaternCovarianceCoeffFn ( const double               length,                               const double               nu,                               const double               sigma,                               const double               nugget,                               const vector< T2Point > &  vertices,                               const TPermutation *       row_perm,                               const TPermutation *       col_perm )        : TPermCoeffFn< real_t >( row_perm, col_perm )        , _length( length )        , _nu( nu )        , _sigmasq( sigma*sigma )        , _nugget( nugget )        , _scale_fac( _sigmasq / ( std::pow(2.0, nu-1) * gsl_sf_gamma(nu) ) )        , _vertices( vertices )        , _matern_type( nu == 0.5 ? one_half : nu == 1.5 ? three_half : nu == 2.5 ? five_half : general )    {}    //    // coefficient evaluation    //    virtual void eval  ( const std::vector< idx_t > &  rowidxs,                         const std::vector< idx_t > &  colidxs,                         real_t *                      matrix ) const    {        const size_t  n = rowidxs.size();        const size_t  m = colidxs.size();        for ( size_t  j = 0; j < m; ++j )        {            const idx_t    idx1 = colidxs[ j ];            const T2Point  y    = _vertices[ idx1 ];                        for ( size_t  i = 0; i < n; ++i )            {                const idx_t    idx0 = rowidxs[ i ];                const T2Point  x    = _vertices[ idx0 ];                const double   dist = norm2( x - y );                switch ( _matern_type )                {                    case one_half :                    {                        matrix[ j*n + i ] = _sigmasq * std::exp( - dist / _length );                    }                    break;                    case three_half :                    {                        const auto  sqrt3drho = SQRT_3 * dist / _length;                                            matrix[ j*n + i ] = _sigmasq * ( 1.0 + sqrt3drho ) * std::exp( - sqrt3drho );                    }                    break;                    case five_half :                    {                        const auto  sqrt5drho = SQRT_5 * dist / _length;                                            matrix[ j*n + i ] = _sigmasq * ( 1.0 + sqrt5drho + ( 5 * dist * dist ) / ( 3 * _length * _length ) ) * std::exp( - sqrt5drho );                    }                    break;                    case general :                    default :                    {                        matrix[ j*n + i ] = compute_Bessel( dist, _length, _nu, _sigmasq );                    }                }// switch            }// for        }// for    }    using TPermCoeffFn< real_t >::eval;    //    // compute modified bessel function    //    double     compute_Bessel ( const double  d,                     const double  rho,                     const double  nu,                     const double  sigmasq ) const    {        if ( d < 1e-16 )            return sigmasq;        else        {            const double temp =  d / rho;            return _scale_fac * gsl_sf_bessel_Knu( nu, temp ) * std::pow( temp, nu );        }// else    }    //    // return format of matrix, e.g. symmetric or hermitian    //    virtual matform_t  matrix_format  () const { return symmetric; }    };//// read data from file//voidread_data ( const string &            datafile,            vector< T2Point > &       vertices,            BLAS::Vector< double > &  Z_data ){    ifstream  in( datafile.c_str() );    string    line;        if ( ! in )    {        std::cout << "error opening " << datafile << std::endl;        exit( 1 );    }// if    size_t  N = 0;        {        std::getline( in, line );        std::istringstream  sline( line );                sline >> N;    }    std::cout << "   " << N << " coordinates" << std::endl;            vertices.resize( N );    Z_data = BLAS::Vector< double >( N );            for ( idx_t  i = 0; i < idx_t(N); ++i )    {        std::getline( in, line );        std::istringstream  sline( line );                        int     index    = i;        double  x, y;        double  v        = 0.0;        // int     property = 1;        sline >> index >> x >> y >> v;        // sline >> x >> y >> v;        vertices[ index ] = T2Point( x, y );        Z_data( index )   = v;    }// for}//// print matrix in different formats//voidprint_matrix ( const TMatrix *  A,               const string &   name ){    TPSMatrixVis  mvis_str, mvis_mem;        mvis_str.color( false ).structure( true ).id( true ).svd( false );    mvis_mem.mem_col( true ).structure( false ).svd( false );            mvis_str.print( A, "loglikelihood_" + name + "s" );    mvis_mem.print( A, "loglikelihood_" + name + "m" );}intmain ( int      argc,       char **  argv ){    INIT();        string  datafile = argv[1];    double  eps       = 1e-7;    double  fac_eps   = 1e-7;    double  shift     = 0.0;    bool    use_ldl   = false;        //    // define command line options    //    options_description             all_opts;    options_description             vis_opts( "usage: loglikelihood [options] datafile\n  where options include" );    options_description             hid_opts( "Hidden options" );    positional_options_description  pos_opts;    variables_map                   vm;    // standard options    vis_opts.add_options()        ( "help,h",                       ": print this help text" )        ( "threads,t",   value<int>(),    ": number of parallel threads" )        ( "verbosity,v", value<int>(),    ": verbosity level" )        ( "eps,e",       value<double>(), ": set H accuracy" )        ( "epslu",       value<double>(), ": set only H factorization accuracy" )        ( "shift",       value<double>(), ": regularization parameter" )        ( "ldl",                          ": use LDL factorization" )        ;        hid_opts.add_options()        ( "data",        value<string>(), ": datafile defining problem" )        ;    // options for command line parsing    all_opts.add( vis_opts ).add( hid_opts );    // all "non-option" arguments should be "--data" arguments    pos_opts.add( "data", -1 );    //    // parse command line options    //    try    {        store( command_line_parser( argc, argv ).options( all_opts ).positional( pos_opts ).run(), vm );        notify( vm );    }// try    catch ( required_option &  e )    {        std::cout << e.get_option_name() << " requires an argument, try \"-h\"" << std::endl;        exit( 1 );    }// catch    catch ( unknown_option &  e )    {        std::cout << e.what() << ", try \"-h\"" << std::endl;        exit( 1 );    }// catch    //    // eval command line options    //    if ( vm.count( "help") )    {        std::cout << vis_opts << std::endl;        exit( 1 );    }// if    if ( vm.count( "eps"       ) ) eps      = vm["eps"].as<double>();    if ( vm.count( "epslu"     ) ) fac_eps  = vm["epslu"].as<double>();    if ( vm.count( "shift"     ) ) shift    = vm["shift"].as<double>();    if ( vm.count( "threads"   ) ) CFG::set_nthreads( vm["threads"].as<int>() );    if ( vm.count( "verbosity" ) ) CFG::set_verbosity( vm["verbosity"].as<int>() );    if ( vm.count( "ldl"       ) ) use_ldl  = true;    // default to general eps    if ( fac_eps == -1 )        fac_eps = eps;        if ( vm.count( "data" ) )        datafile = vm["data"].as<string>();    else    {        std::cout << "usage: loglikelihood [options] datafile" << std::endl;        exit( 1 );    }// if    unique_ptr< TProgressBar >  progress( verbose(2) ? new TConsoleProgressBar : nullptr );        //    // read coordinates    //    std::cout << bold << "━━ reading data ( " << datafile << " )" << normal << std::endl;    vector< T2Point >       vertices;    BLAS::Vector< double >  Z_data;    size_t                  N = 0;    read_data( datafile, vertices, Z_data );    N = vertices.size();        TCoordinate  coord( vertices );    if ( verbose(3) )        print_vtk( & coord, "loglikelihood_coord" );            //    // set up H-matrix structure    //            TAutoBSPPartStrat   part_strat( adaptive_split_axis );    TBSPCTBuilder       ct_builder( & part_strat );    auto                ct = ct_builder.build( & coord );        TStdGeomAdmCond     adm_cond( 2.0, use_min_diam );    TBCBuilder          bct_builder; // keep top levels leaf free    auto                bct = bct_builder.build( ct.get(), ct.get(), & adm_cond );    if ( verbose(3) )        print_ps( bct->root(), "loglikelihood_bct.eps" );    //    // set up Z vector    //    auto  Z = make_unique< TScalarVector >( *ct->root(), Z_data );        // bring vector into H-ordering    ct->perm_e2i()->permute( Z.get() );        //    // data for Matern covariance kernel    //        const double  length = 9.00000000e-02; // 2.0646;     const double  nu     = 0.5;    const double  sigma  = 1.0;    const double  nugget = 1e-4; // 1.0e-1;    //    // build H approximation of C    //    cout << bold << "━━ building H-matrix ( ε = " << format( "%.1e" ) % eps << " )" << normal << endl;            auto                        acc = fixed_prec( eps );    TMaternCovarianceCoeffFn    coefffn( length, nu, sigma, nugget, vertices,                                         ct->perm_i2e(), ct->perm_i2e() );    TACAPlus< real_t >          aca( & coefffn );    TDenseMatBuilder< real_t >  h_builder( & coefffn, & aca );        auto  tic = Time::Wall::now();        auto  C   = h_builder.build( bct.get(), acc, progress.get() );        auto  toc = Time::Wall::since( tic );        cout << "   done in " << toc << ", size = " << mem_per_dof( C ) << std::endl;    if ( verbose(3) )        print_matrix( C.get(), "C" );    DBG::write( C.get(), "C.mat", "C" );        //    // factorise    //        if ( shift != 0.0 )    {        std::cout << bold << "━━ regularization ( C + λ·I, λ = " << format( "%.1e" ) % shift                  << " )" << normal << std::endl;                add_identity( C.get(), shift );    }// if        //    // factorise    //        cout << bold         << "━━ " << ( use_ldl ? "LDL" : "Cholesky" ) << " factorisation"         << " ( ε = " << format( "%.1e" ) % fac_eps << " )" << normal << std::endl;    auto  fac_options = fac_options_t( progress.get() );        // important since we need the diagonal elements    fac_options.eval = point_wise;    auto  C_fac   = C->copy();    auto  fac_acc = fixed_prec( fac_eps );    tic = Time::Wall::now();        if ( use_ldl )        ldl( C_fac.get(), fac_acc, fac_options );    else        chol( C_fac.get(), fac_acc, fac_options );        toc = Time::Wall::since( tic );        unique_ptr< TFacInvMatrix >  C_inv;    if ( use_ldl )        C_inv = make_unique< TLDLInvMatrix >( C_fac.get(), symmetric, point_wise );    else        C_inv = make_unique< TLLInvMatrix >( C_fac.get(), symmetric );        cout << "   done in " << toc << ", size = " << mem_per_dof( C_fac ) << ", "         << "error = " << format( "%.6e" ) % inv_approx_2( C.get(), C_inv.get() ) << std::endl;    if ( verbose(3) )        print_matrix( C_fac.get(), "L" );    //    // compute log( det( C ) ) = log( det( L L ) )   = 2*log( det( L ) )    // or                      = log( det( L D L ) ) =   log( det( D ) )    //        double  log_det_C = 0.0;        for ( idx_t  i = 0; i < idx_t(N); ++i )    {        const auto  c_ii = C_fac->entry( i, i );                if ( use_ldl ) log_det_C += std::log( c_ii );        else           log_det_C += 2*std::log( c_ii );    }// for        cout << "   log(det(C)) = " << format( "%.6e" ) % log_det_C << std::endl;        //    // solve RHS    //        cout << bold << "━━ solving RHS" << normal << endl;        CFG::Solver::use_exact_residual = true;        TStopCriterion  sstop( 250, 1e-16, 0.0 );    TCG             solver( sstop );    TSolverInfo     sinfo( false, verbose( 4 ) );    auto            sol = C->row_vector();        solver.solve( C.get(), sol.get(), Z.get(), C_inv.get(), & sinfo );        if ( verbose(1) )        cout << "   " << sinfo << std::endl;            auto            ZdotCZ = re( Z->dot( sol.get() ) );    auto            LL     = 0.5 * ( N * std::log( 2.0 * Math::pi<double>() ) + log_det_C + ZdotCZ );    cout << "   " << "LogLi = " << format( "%.8e" ) % LL << std::endl;        DONE();     return 0;}