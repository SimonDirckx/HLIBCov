/* * Project     : HLib * File        : bem1d.c * Description : example for 1d BEM problem * Author      : Ronald Kriemann * Copyright   : Max Planck Institute MIS 2004-2014. All Rights Reserved. * */#include <iostream>#include <fstream>#include <vector>#include <boost/format.hpp>#include <boost/math/special_functions/gamma.hpp>#include <boost/math/special_functions/bessel.hpp>#include <gsl/gsl_sf_bessel.h>#include <gsl/gsl_sf_gamma.h>#include <hlib.hh>using namespace std;using namespace HLIB;using boost::format;using HLIB::Time::Wall::now;using HLIB::Time::Wall::since;using real_t = HLIB::real;int global_k;double global_eps;double l1, l2;double step_h;int nmin;template < typename T >stringmem_per_dof ( T && A ){    const size_t  mem  = A->byte_size();    const size_t  pdof = size_t( double(mem) / double(A->rows()) );    return Mem::to_string( mem ) + " (" + Mem::to_string( pdof ) + "/dof)";}double compute_Bessel ( double  d,                 double  pho,                 double  nu,                 double  sigma2 ){    const double temp =  d / pho;    if (d<1e-16)        return sigma2;    else    {        return sigma2 * gsl_sf_bessel_Knu(nu, temp) * std::pow(temp, nu) / std::pow(2.0, nu-1) / gsl_sf_gamma(nu);        // return sigma2 * boost::math::cyl_bessel_k( nu, temp ) * std::pow(temp, nu) / std::pow(2.0, nu-1) / boost::math::tgamma( nu );    }// else}//// covariance coefficient function//class TCovCoeffFn : public TPermCoeffFn< real_t >{private:    const double                _length;    const double                _nu;    const double                _sigma2;    const double                _nugget;    const vector< double * > &  _vertices;public:    // constructor    TCovCoeffFn ( const double               length,                  const double               nu,                  const double               sigma2,                  const double               nugget,                  const vector< double * > & vertices,                  const TPermutation *       row_perm,                  const TPermutation *       col_perm )            : TPermCoeffFn< real_t >( row_perm, col_perm )            , _length( length )            , _nu( nu )            , _sigma2( sigma2 )            , _nugget( nugget )            , _vertices( vertices )    {}    //    // coefficient evaluation    //    virtual void eval  ( const std::vector< idx_t > &  rowidxs,                         const std::vector< idx_t > &  colidxs,                         real_t *                      matrix ) const    {        const size_t  n = rowidxs.size();        const size_t  m = colidxs.size();        for ( size_t  j = 0; j < m; ++j )        {            const idx_t     idx1 = colidxs[ j ];            const double *  y    = _vertices[ idx1 ];                        for ( size_t  i = 0; i < n; ++i )            {                const idx_t     idx0 = rowidxs[ i ];                const double *  x    = _vertices[ idx0 ];                const double    dist = Math::sqrt( Math::square( x[0] - y[0] ) + Math::square( x[1] - y[1] ) );                matrix[ j*n + i ] = compute_Bessel( dist, _length, _nu, _sigma2 );                             }// for        }// for    }    using TPermCoeffFn< real_t >::eval;    //    // return format of matrix, e.g. symmetric or hermitian    //    virtual matform_t  matrix_format  () const { return symmetric; }    };//Use a method described by Abramowitz and Stegun: double gaussrand_Stegun(){    static double U, V;    static int phase = 0;    double Z;    if(phase == 0) {        U = (rand() + 1.) / (RAND_MAX + 2.);        V = rand() / (RAND_MAX + 1.);        Z = sqrt(-2 * log(U)) * sin(2 * M_PI * V);    } else        Z = sqrt(-2 * log(U)) * cos(2 * M_PI * V);    phase = 1 - phase;    return Z;}//Use a method discussed in Knuth and due originally to Marsaglia:double gaussrand_Knuth(){    static double V1, V2, S;    static int phase = 0;    double X;    if(phase == 0) {        do {            double U1 = (double)rand() / RAND_MAX;            double U2 = (double)rand() / RAND_MAX;            V1 = 2 * U1 - 1;            V2 = 2 * U2 - 1;            S = V1 * V1 + V2 * V2;        } while(S >= 1 || S == 0);        X = V1 * sqrt(-2 * log(S) / S);    } else        X = V2 * sqrt(-2 * log(S) / S);    phase = 1 - phase;    return X;}intmain ( int argc, char ** argv ){    INIT();    CFG::set_verbosity( 1 );                             string datename= "/home/litvina/111gsl/data_ying/Synthetic_sets/synthetic_128000_1.txt";               //string  datename = "/home/litvina/111gsl/data_ying/nonnested_moist_whole/moist_2000_1";   /*     string  datename = "/home/litvina/111gsl/data_ying/nonnested_moist_whole/moist_4000_1";    string  datename = "/home/litvina/111gsl/data_ying/nonnested_moist_whole/moist_8000_1";    string  datename = "/home/litvina/111gsl/data_ying/nonnested_moist_whole/moist_16000_1";    string  datename = "/home/litvina/111gsl/data_ying/nonnested_moist_whole/moist_32000_1";    string  datename = "/home/litvina/111gsl/data_ying/nonnested_moist_whole/moist_64000_1";    string  datename = "/home/litvina/111gsl/data_ying/nonnested_moist_whole/moist_128000_1";    */    if ( argc > 1 )        datename = argv[1];        unique_ptr< TProgressBar >  progress( verbose(2) ? new TConsoleProgressBar : nullptr );        //    // read coordinates    //    vector< double * >  vertices;    TScalarVector       rhs;    int                 dim = 2;    int                 N   = 0;        {        ifstream  in( datename.c_str() );        if ( ! in )        {            cout << "error opening " << datename << endl;            exit( 1 );        }// if        in >> N;        cout << "  reading " << N << " coordinates" << endl;                vertices.resize( N );        rhs.set_size( N );        for ( int  i = 0; i < N; ++i )        {            int     index, property=1;            double  x, y, v=0.0;           // in >> index >> x >> y >> property >> v;//            in >> index >> x >> y;            in >> x >> y >> v;            vertices[i] = new double[ dim ];            vertices[i][0] = x;            vertices[i][1] = y;            rhs.set_entry( i, v );           // printf("%4.4g %4.4g %4.4g \n", x,y,v);                    }// for    }    TCoordinate  coord( vertices, dim );                //    // clustering    //    TAutoBSPPartStrat   part_strat( adaptive_split_axis );    TBSPCTBuilder       ct_builder( & part_strat );    auto                ct = ct_builder.build( & coord );        TStdGeomAdmCond     adm_cond( 2.0, use_min_diam );    TBCBuilder          bct_builder( std::log2( 16 ) );    auto                bct = bct_builder.build( ct.get(), ct.get(), & adm_cond );   // bring RHS into H-ordering    ct->perm_e2i()->permute( & rhs );        double  length = 0.089;     double  nu     = 0.5;    double  sigma2 = 1.0;    double  nugget = 0.0;    FILE* f4;        for ( int  count0 = 1; count0 < 14; count0++ )     {        nu = 0.18 + 0.04 * count0;        cout << endl << "step " << count0 << " ( length = " << length << " )" << endl;                auto                        acc = fixed_prec( 1e-5 );        TCovCoeffFn                 coefffn( length,                                             nu,                                             sigma2,                                             nugget,                                             vertices,                                             ct->perm_i2e(), ct->perm_i2e() );        TACAPlus< real_t >          aca( & coefffn );        TDenseMatBuilder< real_t >  h_builder( & coefffn, & aca );        //        // build H-matrix        //                cout << "  building H-matrix" << endl;                auto  tic = now();                auto  A = h_builder.build( bct.get(), acc, progress.get() );        auto  toc = since( tic );                      unique_ptr< TMatrix >  A_ref;           cout << "  factorization" << endl;                auto  A_copy  = A->copy();        auto  options = fac_options_t( progress.get() );        options.eval = point_wise;        tic = now();        auto  A_inv = ldl_inv( A_copy.get(), acc, options );                toc = since( tic );        cout << "    done in " << toc << endl;        cout << "    size of LU factor = " << mem_per_dof( A_copy ) << endl;           double  s = 0.0;                for ( int  i = 0; i < N; ++i )        {            const auto  v = A_copy->entry( i, i );                        s += log(v); // should be 2*log(v) for Cholesky        }// for        std::cout << "    log det C (from LDL^T) = " << format( "%.6e" ) % s << std::endl;        //        // solve RHS        //        cout << "  solve RHS" << endl;        TStopCriterion  sstop( 150, 1e-12, 0.0 );        TCG             solver( sstop );        TSolverInfo     sinfo( false, verbose( 4 ) );        auto            sol = A->row_vector();                solver.solve( A.get(), sol.get(), & rhs, A_inv.get(), & sinfo );        std::cout << "    " << sinfo << std::endl;                auto            dotp = re( rhs.dot( sol.get() ) );        auto            LL = 0.5 * N * log( 2.0 * Math::pi<double>() ) + s + dotp;        std::cout << "    LogLi = " << format( "%.8e" ) % LL << std::endl;        f4 = fopen( "111logli_nu_7June2017.txt", "a+");        fprintf(f4, " %d %4.4g  %4.4g  %4.4g  %12.10e %12.10e %12.10e \n", N, length, nu, sigma2, s, dotp, LL);    //   fprintf(f4, " %d  %12.10e %12.10e \n", jj, gl_min_nu, gl_min_LL);         fclose(f4);    }// for        DONE();        return 0;}